// 引用：#include <conio.h>#include <cstdlib>#include <ctime>#include <iomanip>#include <iostream>// 变量和常量：int *x;int *y;int *_x;int *_y;int n_aux;int n_outer;int n_inner;enum HV { kHorizontal, kVertical };enum GameStatus { kStatusPlaying, kStatusWin, kStatusFail };struct Game {  GameStatus status;  int score;  int block[4][4];};struct GameDirection {  HV hv;  int loop_start;  int loop_end;  int loop_step;  int CanLoop(int i) {    if (loop_start <= loop_end)      return (i <= loop_end);    else      return (i >= loop_end);  }};Game game = {kStatusPlaying, 0, 0};GameDirection direction_left = {kHorizontal, 0, 3, 1};GameDirection direction_right = {kHorizontal, 3, 0, -1};GameDirection direction_up = {kVertical, 0, 3, 1};GameDirection direction_down = {kVertical, 3, 0, -1};GameDirection *direction = NULL;// 函数：// 输出方块：void PrintBlock() {  system("cls");  std::cout << "-------------------------------------" << std::endl;  std::cout << "|   _____   _____   _   _   _____   |" << std::endl;  std::cout << "|  /___  \\ /  _  \\ | | | | /  _  \\  |" << std::endl;  std::cout << "|   ___| | | | | | | |_| | | |_| |  |" << std::endl;  std::cout << "|  /  ___/ | |/| | \\___  | }  _  {  |" << std::endl;  std::cout << "|  | |___  | |_| |     | | | |_| |  |" << std::endl;  std::cout << "|  |_____| \\_____/     |_| \\_____/  |" << std::endl;  std::cout << "|                                   |" << std::endl;  std::cout << "|-----------------------------------|" << std::endl;  std::cout << "|"            << " Status: " << std::setw(7) << game.status << " |"            << " Score: " << std::setw(8) << game.score << " |" << std::endl;  for (int j = 0; j <= 3; ++j) {    std::cout << "|-----------------------------------|" << std::endl;    for (int i = 0; i <= 3; ++i) {      if (game.block[i][j] == 0)        std::cout << "|" << std::setw(8) << "";      else        std::cout << "|" << std::setw(8) << game.block[i][j];    }    std::cout << "|" << std::endl;  }  std::cout << "|-----------------------------------|" << std::endl;}// 随机方块：// - 这里生成 4 的概率是 0.1void RandomBlock(int count) {  int i, j;  int is_4 = 0;  for (int n = 0; n < count; ++n) {    srand((unsigned int)time(0));    do {      i = rand() % 4;      j = rand() % 4;    } while (game.block[i][j] != 0);    is_4 = rand() % 10;    if (is_4 == 9)      game.block[i][j] = 4;    else      game.block[i][j] = 2;  }}// 设置横纵方向：// - 这里的原理是用指针，使改变 n_aux 就能改变方块横或纵方向的坐标// 注：// - n_inner 是内层循环的迭代数，n_outer 是外层循环的迭代数void SetHV() {  if (direction->hv == kHorizontal) {    x = &n_inner;    y = &n_outer;    _x = &n_aux;    _y = &n_outer;  } else if (direction->hv == kVertical) {    x = &n_outer;    y = &n_inner;    _x = &n_outer;    _y = &n_aux;  }}// 移动方块：// - 这里原理是从前往后找非空方块（game.block[*x][*y]）// - 并把它移动到最靠前的空方块（game.block[*_x][*_y]）// 注：// - 1. 靠近 loop_start 为前，靠近 loop_end 为后// - 2. n_aux 记录了最靠前的空方块的位置，找到一个非空方块就向后走一步// - 3. 这使 game.block[*_x][*_y] 成为最靠前的空方块bool MoveBlock(bool check_mode) {  SetHV();  bool is_moved = false;  for (n_outer = direction->loop_start; direction->CanLoop(n_outer);       n_outer += direction->loop_step) {    n_aux = direction->loop_start;    for (n_inner = direction->loop_start; direction->CanLoop(n_inner);         n_inner += direction->loop_step) {      if (game.block[*x][*y] != 0) {        if (game.block[*_x][*_y] == 0) {          if (check_mode) {            return true;          } else {            game.block[*_x][*_y] = game.block[*x][*y];            game.block[*x][*y] = 0;            is_moved = true;          }        }        n_aux += direction->loop_step;      }    }  }  if (check_mode) return false;  return is_moved;}// 合并方块：// - 这里的原理是依次处理前两个、中间两个、后两个方块// 注：// - 1. 靠近 loop_start 为前，靠近 loop_end 为后// - 2. 这里的 n_aux 始终是 game.block[*x][*y] 的下一个方块的位置// - 3. 这使 game.block[*_x][*_y] 始终为 game.block[*x][*y] 的下一个方块bool MergeBlock(bool check_mode) {  SetHV();  bool is_merged = false;  for (n_outer = direction->loop_start; direction->CanLoop(n_outer);       n_outer += direction->loop_step) {    for (n_inner = direction->loop_start; direction->CanLoop(n_inner);         n_inner += direction->loop_step) {      n_aux = n_inner + direction->loop_step;      if (n_aux < 0 || n_aux > 3) break;      if (game.block[*_x][*_y] != 0 &&          game.block[*x][*y] == game.block[*_x][*_y]) {        if (check_mode) {          return true;        } else {          game.block[*x][*y] *= 2;          game.block[*_x][*_y] = 0;          game.score += game.block[*x][*y];          is_merged = true;        }      }    }  }  if (check_mode) return false;  return is_merged;}// 处理方块：// - 移动完合并，若能合并，则再移动一次bool HandleBlock() {  bool is_moved = false;  bool is_merged = false;  bool is_handled = false;  is_moved = MoveBlock(false);  is_merged = MergeBlock(false);  if (is_merged) is_moved = MoveBlock(false);  if (is_moved || is_merged) is_handled = true;  return is_handled;}// 检查状态：// - 出现方块 2048// - => 改变 game.status 为游戏胜利(kStatusWin)// - 有空方块或各方向仍可以合并// - => 不改变 game.status// - => 仍为游戏运行中（kStatusPlaying）// - 不满足以上// - => 改变 game.status 为游戏失败(kStatusFail)void CheckStatus() {  int count = 0;  for (int j = 0; j <= 3; ++j)    for (int i = 0; i <= 3; ++i) {      if (game.block[i][j] == 0) ++count;      if (game.block[i][j] == 2048) {        game.status = kStatusWin;        return;      }    }  if (count != 0) return;  direction = &direction_up;  if (MergeBlock(true)) return;  direction = &direction_down;  if (MergeBlock(true)) return;  direction = &direction_left;  if (MergeBlock(true)) return;  direction = &direction_right;  if (MergeBlock(true)) return;  game.status = kStatusFail;}// 读取键盘输入：void GetInput() {  char input = (char)getch();  switch (input) {    case 'w':      direction = &direction_up;      break;    case 's':      direction = &direction_down;      break;    case 'a':      direction = &direction_left;      break;    case 'd':      direction = &direction_right;      break;    default:      GetInput();  }}// 主函数：int main() {  system("mode con cols=38 lines=21");  system("title 2048");  system("color F0");  RandomBlock(2);  while(true) {    CheckStatus();    PrintBlock();    if (game.status != kStatusPlaying) break;    do GetInput();    while (!HandleBlock());    RandomBlock(1);  }  if (game.status == kStatusFail) {    std::cout << "Game Over." << std::endl;  } else if (game.status == kStatusWin) {    std::cout << "Well done." << std::endl;  }  return 0;}